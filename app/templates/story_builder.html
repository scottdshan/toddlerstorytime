{% extends "base.html" %}

{% block title %}Create a Story - Toddler Storyteller{% endblock %}

{% set active_page = 'builder' %}

{% block content %}
<div class="row justify-content-center">
    <div class="col-md-10">
        <h1 class="text-center mb-4">Create a Bedtime Story</h1>
        
        <div class="card mb-4">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <h3 class="mb-0">Story Builder</h3>
                    <button id="randomizeBtn" class="btn btn-secondary">
                        <i class="fas fa-random me-2"></i>Randomize
                    </button>
                </div>
                
                <form id="storyForm">
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="childName" class="form-label">Child's Name</label>
                            <input type="text" class="form-control" id="childName" name="childName" value="Wesley">
                        </div>
                        
                        <div class="col-md-6 mb-3">
                            <label for="universe" class="form-label">Story Universe</label>
                            <select class="form-select" id="universe" name="universe" required>
                                <option value="" disabled selected>Select a universe</option>
                                <!-- Options will be populated via JavaScript -->
                            </select>
                        </div>
                    </div>
                    
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="setting" class="form-label">Story Setting</label>
                            <select class="form-select" id="setting" name="setting" required>
                                <option value="" disabled selected>Select a setting</option>
                                <!-- Options will be populated via JavaScript -->
                            </select>
                        </div>
                        
                        <div class="col-md-6 mb-3">
                            <label for="theme" class="form-label">Story Theme</label>
                            <select class="form-select" id="theme" name="theme" required>
                                <option value="" disabled selected>Select a theme</option>
                                <!-- Options will be populated via JavaScript -->
                            </select>
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Characters</label>
                        <div id="charactersContainer" class="border rounded p-3">
                            <!-- Character checkboxes will be populated via JavaScript -->
                            <div class="row" id="charactersList"></div>
                        </div>
                    </div>
                    
                    <div class="row">
                        <div class="col-md-6 mb-3">
                            <label for="storyLength" class="form-label">Story Length</label>
                            <select class="form-select" id="storyLength" name="storyLength" required>
                                <option value="" disabled selected>Select length</option>
                                <!-- Options will be populated via JavaScript -->
                            </select>
                        </div>
                        
                        <div class="col-md-6 mb-3">
                            <label for="llmProvider" class="form-label">AI Provider</label>
                            <select class="form-select" id="llmProvider" name="llmProvider">
                                <option value="openai">OpenAI</option>
                                <option value="anthropic">Claude</option>
                                <option value="azure">Azure OpenAI</option>
                                <option value="local">Local OpenAI API</option>
                            </select>
                        </div>
                        
                        <div class="col-md-6 mb-3" id="modelSelectContainer" style="display: none;">
                            <label for="modelSelect" class="form-label">Model</label>
                            <select class="form-select" id="modelSelect" name="model">
                                <!-- Will be populated dynamically based on provider -->
                            </select>
                        </div>
                        
                        <div class="col-md-6 mb-3">
                            <label for="ttsProvider" class="form-label">Voice Provider</label>
                            <select class="form-select" id="ttsProvider" name="ttsProvider">
                                <option value="elevenlabs">ElevenLabs</option>
                                <option value="amazon">Amazon Polly</option>
                                <option value="piper">Piper (Local TTS)</option>
                                <option value="none">None (Testing)</option>
                            </select>
                        </div>
                        
                        <div class="col-md-6 mb-3" id="voiceSelectContainer">
                            <label for="voiceSelect" class="form-label">Voice</label>
                            <select class="form-select" id="voiceSelect" name="voice_id">
                                <option value="">Loading voices...</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-check mb-4">
                        <input class="form-check-input" type="checkbox" id="useStreamingMode">
                        <label class="form-check-label" for="useStreamingMode">
                            Use streaming mode (generate text and audio in real-time)
                        </label>
                    </div>
                    
                    <div class="text-center mt-4">
                        <button type="submit" id="generateBtn" class="btn btn-primary btn-lg">
                            <i class="fas fa-wand-magic-sparkles me-2"></i>Generate Story
                        </button>
                    </div>
                </form>
            </div>
        </div>
        
        <!-- Story Result Container (Initially Hidden) -->
        <div id="storyResult" class="card mb-4" style="display: none;">
            <div class="card-body">
                <h3 id="storyTitle" class="text-center mb-3"></h3>
                
                <div class="text-center mb-4">
                    <div id="audioPlayer" class="audio-player">
                        <!-- Keep the audio element but hide it visually -->
                        <audio id="storyAudio" style="display: none;"></audio>
                    </div>
                </div>
                
                <div id="storyText" class="story-text"></div>
                
                <div class="d-flex justify-content-center mt-4">
                    <button id="playLocallyBtn" class="btn btn-success me-2" style="display: none;">
                        <i class="fas fa-headphones me-2"></i>Play Locally
                    </button>
                    <button id="regenerateBtn" class="btn btn-secondary me-2">
                        <i class="fas fa-sync me-2"></i>Regenerate
                    </button>
                    <button id="playOnHaBtn" class="btn btn-info me-2" style="display: none;">
                        <i class="fas fa-broadcast-tower me-2"></i>Play on Home Assistant
                    </button>
                    <button id="newStoryBtn" class="btn btn-primary">
                        <i class="fas fa-plus me-2"></i>New Story
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Loading Indicator (Initially Hidden) -->
        <div id="loadingContainer" class="text-center my-5" style="display: none;">
            <div class="card p-5 pulse-animation">
                <h3>Creating Your Story</h3>
                <div class="progress mt-3 mb-3">
                    <div id="progressBar" class="progress-bar progress-bar-striped progress-bar-animated" 
                         role="progressbar" style="width: 0%"></div>
                </div>
                <p id="loadingMessage">Gathering story elements...</p>
            </div>
        </div>
        
        <!-- Home Assistant Player Selection Modal -->
        <div class="modal fade" id="haPlayerModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Select Media Player</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div id="ha-player-list">
                            <div class="text-center py-3">
                                <div class="spinner-border text-primary" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                                <p class="mt-2">Loading media players...</p>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Home Assistant Player Controls -->
        <div id="player-controls" class="fixed-bottom bg-light shadow-lg p-3 d-none">
            <div class="container">
                <div class="row align-items-center">
                    <div class="col-md-6">
                        <h5 class="mb-0"><i class="fas fa-broadcast-tower me-2"></i> Playing on Home Assistant</h5>
                    </div>
                    <div class="col-md-6 text-end">
                        <button id="pause-resume-ha-btn" class="btn btn-primary">
                            <i class="fas fa-pause me-1"></i> Pause
                        </button>
                        <button id="close-player-btn" class="btn btn-outline-secondary ms-2">
                            <i class="fas fa-times me-1"></i> Close
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize the model options for different providers
        initializeModelOptions();
        
        // Load user preferences
        loadUserPreferences();
        
        // Add event listeners for provider changes
        document.getElementById('llmProvider').addEventListener('change', function() {
            updateModelOptions(this.value);
        });
        
        document.getElementById('ttsProvider').addEventListener('change', function() {
            loadVoices(this.value);
        });
        
        // Story settings
        const storySettings = {
            universes: [
                "Paw Patrol", "Disney Princess", "PJ Masks", "Bluey", 
                "Peppa Pig", "Cocomelon", "Toy Story", "Mickey Mouse Clubhouse", 
                "Sesame Street", "Original Fantasy World"
            ],
            settings: [
                "Bedtime", "Playground", "Beach", "Zoo", "Farm", "Space", 
                "Underwater", "Forest", "Jungle", "Mountains", "School", 
                "Doctor's Office", "Rainy Day", "Snowy Day", "Birthday Party"
            ],
            themes: [
                "Friendship", "Helping Others", "Trying New Things", "Facing Fears", 
                "Being Kind", "Learning New Skills", "Listening to Parents", "Sharing", 
                "Patience", "Being Brave", "Taking Turns", "Apologizing", "Gratitude",
                "Sleep Routine", "Morning Routine"
            ],
            characters: [
                "Wesley", "Mom", "Dad", "Chase", "Marshall", "Skye", "Rubble", 
                "Rocky", "Zuma", "Ryder", "Elsa", "Anna", "Olaf", "Mickey Mouse", 
                "Minnie Mouse", "Bluey", "Bingo", "Bandit", "Chilli"
            ],
            storyLengths: [
                "Very Short (2-3 minutes)", "Short (3-5 minutes)", 
                "Medium (5-7 minutes)", "Long (7-10 minutes)"
            ]
        };
        
        // Populate form dropdowns and character options
        function populateFormOptions() {
            // Populate universe dropdown
            const universeSelect = document.getElementById('universe');
            storySettings.universes.forEach(universe => {
                const option = document.createElement('option');
                option.value = universe;
                option.textContent = universe;
                universeSelect.appendChild(option);
            });
            
            // Populate setting dropdown
            const settingSelect = document.getElementById('setting');
            storySettings.settings.forEach(setting => {
                const option = document.createElement('option');
                option.value = setting;
                option.textContent = setting;
                settingSelect.appendChild(option);
            });
            
            // Populate theme dropdown
            const themeSelect = document.getElementById('theme');
            storySettings.themes.forEach(theme => {
                const option = document.createElement('option');
                option.value = theme;
                option.textContent = theme;
                themeSelect.appendChild(option);
            });
            
            // Populate story length dropdown
            const lengthSelect = document.getElementById('storyLength');
            storySettings.storyLengths.forEach(length => {
                const option = document.createElement('option');
                option.value = length;
                option.textContent = length;
                lengthSelect.appendChild(option);
            });
            
            // Populate character checkboxes
            const charactersList = document.getElementById('charactersList');
            storySettings.characters.forEach((character, index) => {
                const charDiv = document.createElement('div');
                charDiv.className = 'col-md-4 mb-2';
                charDiv.innerHTML = `
                    <div class="form-check">
                        <input class="form-check-input character-checkbox" type="checkbox" 
                               name="character" value="${character}" id="char${index}">
                        <label class="form-check-label" for="char${index}">
                            ${character}
                        </label>
                    </div>
                `;
                charactersList.appendChild(charDiv);
            });
            
            // Check the first 3 characters by default (including Wesley)
            for (let i = 0; i < 3 && i < storySettings.characters.length; i++) {
                document.getElementById(`char${i}`).checked = true;
            }
        }
        
        // Initialize form
        populateFormOptions();
        
        // Load available voices for the selected TTS provider
        loadVoices(document.getElementById('ttsProvider').value);
        
        // Form submission handler
        document.getElementById('storyForm').addEventListener('submit', function(e) {
            e.preventDefault();
            generateStory(false);
        });
        
        // Randomize button handler
        document.getElementById('randomizeBtn').addEventListener('click', function() {
            generateStory(true);
        });
        
        // Regenerate button handler
        document.getElementById('regenerateBtn').addEventListener('click', function() {
            generateStory(false);
        });
        
        // Audio element ended event listener
        document.getElementById('storyAudio').addEventListener('ended', function() {
            showToast('Audio playback complete', 'info');
        });
        
        // Story generation function
        async function generateStory(randomize) {
            try {
                // Show loading state
                document.getElementById('storyForm').style.display = 'none';
                document.getElementById('loadingContainer').style.display = 'block';
                document.getElementById('storyResult').style.display = 'none';
                document.getElementById('progressBar').style.width = '0%';
                document.getElementById('loadingMessage').textContent = "Gathering story elements...";
                
                // Clear any previous interval
                if (window.progressInterval) {
                    clearInterval(window.progressInterval);
                }
                
                // Start progress simulation
                simulateProgress();
                
                // Get form values
                const universe = document.getElementById('universe').value;
                const setting = document.getElementById('setting').value;
                const theme = document.getElementById('theme').value;
                const story_length = document.getElementById('storyLength').value;
                const child_name = document.getElementById('childName').value;
                
                // Check if required fields are filled
                if (!universe || !setting || !theme || !story_length || !child_name) {
                    showToast('Please fill out all required fields', 'warning');
                    // Reset form display
                    document.getElementById('storyForm').style.display = 'block';
                    document.getElementById('loadingContainer').style.display = 'none';
                    return;
                }
                
                // Get selected characters
                const characterCheckboxes = document.querySelectorAll('input[name="character"]:checked');
                
                console.log("Selected characters:", characterCheckboxes);
                
                const characters = Array.from(characterCheckboxes).map(checkbox => {
                    return {
                        character_name: checkbox.value
                    };
                });
                
                // Log for debugging
                console.log("Characters array:", characters);
                
                // Check if at least one character is selected
                if (characters.length === 0) {
                    showToast('Please select at least one character', 'warning');
                    // Reset form display
                    document.getElementById('storyForm').style.display = 'block';
                    document.getElementById('loadingContainer').style.display = 'none';
                    return;
                }
                
                // Get provider selections
                const llm_provider = document.getElementById('llmProvider').value;
                const tts_provider = document.getElementById('ttsProvider').value;
                
                // Get model and voice selections if applicable
                let model = null;
                let voice_id = null;
                
                // If a provider requires a model, get the selected model
                if (llm_provider === 'openai' || llm_provider === 'anthropic' || 
                    llm_provider === 'azure' || llm_provider === 'local') {
                    model = document.getElementById('modelSelect').value;
                }
                
                // Get voice selection if not using 'none' provider
                if (tts_provider !== 'none') {
                    voice_id = document.getElementById('voiceSelect').value;
                }
                
                // For local provider, we need to get the API URL from preferences
                let local_api_url = null;
                if (llm_provider === 'local') {
                    // Get from preferences
                    const prefs = JSON.parse(localStorage.getItem('userPreferences') || '{}');
                    local_api_url = prefs.local_api_url || null;
                    
                    if (!local_api_url) {
                        showToast('Please set up your Local API URL in Preferences first', 'warning');
                        // Reset form display
                        document.getElementById('storyForm').style.display = 'block';
                        document.getElementById('loadingContainer').style.display = 'none';
                        return;
                    }
                    
                    if (!model) {
                        showToast('Please select a model', 'warning');
                        // Reset form display
                        document.getElementById('storyForm').style.display = 'block';
                        document.getElementById('loadingContainer').style.display = 'none';
                        return;
                    }
                }
                
                // Create the request object
                const storyRequest = {
                    universe,
                    setting,
                    theme,
                    story_length,
                    child_name,
                    characters,
                    llm_provider,
                    tts_provider,
                    voice_id,
                    model,
                    local_api_url,
                    randomize: randomize === true
                };
                
                console.log('Generating story with request:', storyRequest);
                
                // Choose between streaming and regular generation
                const useStreaming = document.getElementById('useStreamingMode').checked;
                
                if (useStreaming) {
                    await generateStoryStreaming(storyRequest);
                } else {
                    // Submit to API
                    const response = await fetch('/api/stories/generate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(storyRequest)
                    });
                    
                    // Check for errors
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || 'Failed to generate story');
                    }
                    
                    // Parse response
                    const storyData = await response.json();
                    
                    // Update progress to 100%
                    document.getElementById('progressBar').style.width = '100%';
                    
                    // Show story
                    showStory(storyData);
                }
                
            } catch (error) {
                console.error('Error generating story:', error);
                
                // Stop progress simulation
                if (window.progressInterval) {
                    clearInterval(window.progressInterval);
                }
                
                // Show error in UI
                const loadingMessage = document.getElementById('loadingMessage');
                if (loadingMessage) {
                    loadingMessage.innerHTML = `<i class="fas fa-exclamation-circle text-danger"></i> Error: ${error.message}`;
                }
                
                // Add a retry button
                const loadingContainer = document.getElementById('loadingContainer');
                if (loadingContainer) {
                    const retryBtn = document.createElement('button');
                    retryBtn.className = 'btn btn-primary mt-3';
                    retryBtn.innerHTML = '<i class="fas fa-sync-alt me-2"></i>Try Again';
                    retryBtn.onclick = () => {
                        document.getElementById('storyForm').style.display = 'block';
                        document.getElementById('loadingContainer').style.display = 'none';
                        // Remove the retry button
                        while (loadingContainer.querySelector('button')) {
                            loadingContainer.querySelector('button').remove();
                        }
                    };
                    loadingContainer.appendChild(retryBtn);
                }
                
                // Show error notification
                showToast('Error generating story: ' + error.message, 'danger');
            }
        }
        
        // Streaming story generation function
        async function generateStoryStreaming(storyRequest) {
            try {
                // Prepare UI for streaming
                const storyResultContainer = document.getElementById('storyResult');
                if (!storyResultContainer) {
                    throw new Error("Cannot find story result container");
                }
                storyResultContainer.style.display = 'block';
                
                // Create streaming content elements if they don't exist
                if (!document.getElementById('streamingContent')) {
                    const streamingDiv = document.createElement('div');
                    streamingDiv.id = 'streamingContent';
                    streamingDiv.className = 'streaming-content';
                    
                    const storyTextDiv = document.createElement('div');
                    storyTextDiv.id = 'streamingStoryText';
                    storyTextDiv.className = 'story-text';
                    
                    const audioControlDiv = document.createElement('div');
                    audioControlDiv.id = 'streamingAudioControl';
                    audioControlDiv.className = 'audio-control mt-4';
                    
                    const audioPlayer = document.createElement('audio');
                    audioPlayer.id = 'streamingAudioPlayer';
                    audioPlayer.controls = true;
                    
                    audioControlDiv.appendChild(audioPlayer);
                    streamingDiv.appendChild(storyTextDiv);
                    streamingDiv.appendChild(audioControlDiv);
                    storyResultContainer.innerHTML = '';
                    storyResultContainer.appendChild(streamingDiv);
                }
                
                const storyTextDiv = document.getElementById('streamingStoryText');
                storyTextDiv.innerHTML = '<h3>Generating story...</h3>';
                
                // Make API request to streaming endpoint
                const response = await fetch('/api/stories/generate_streaming', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(storyRequest)
                });
                
                if (!response.ok) {
                    throw new Error(`Server error: ${response.status}`);
                }
                
                // Set up event source for SSE
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let storyText = '';
                
                // --- MSE Setup ---
                const audioElement = document.getElementById('streamingAudioPlayer');
                if (!audioElement) {
                    throw new Error("Cannot find streaming audio player element");
                }
                const mediaSource = new MediaSource();
                audioElement.src = URL.createObjectURL(mediaSource);
                let sourceBuffer = null;
                let audioQueue = []; // Use queue temporarily before sourceBuffer is ready
                let isAppending = false; // Flag to manage buffer appends
                
                mediaSource.addEventListener('sourceopen', () => {
                    console.log('MediaSource opened');
                    try {
                        // Assuming MP3 audio from TTS providers
                        sourceBuffer = mediaSource.addSourceBuffer('audio/mpeg'); 
                        
                        sourceBuffer.addEventListener('updateend', () => {
                            isAppending = false;
                            // If there's more in the queue, append it
                            appendNextChunk(); 
                        });
                        
                        sourceBuffer.addEventListener('error', (e) => {
                            console.error('SourceBuffer error:', e);
                        });
                        
                        // Process any chunks that arrived before sourceopen
                        appendNextChunk();
                        
                    } catch (e) {
                        console.error('Error adding SourceBuffer:', e);
                    }
                });
                
                mediaSource.addEventListener('sourceended', () => {
                    console.log('MediaSource ended');
                });
                mediaSource.addEventListener('sourceclose', () => {
                    console.log('MediaSource closed');
                });
                mediaSource.addEventListener('error', (e) => {
                    console.error('MediaSource error:', e);
                });
                
                // Function to append the next chunk from the queue
                function appendNextChunk() {
                    if (!isAppending && sourceBuffer && audioQueue.length > 0) {
                        isAppending = true;
                        const chunkToAppend = audioQueue.shift();
                        try {
                             sourceBuffer.appendBuffer(chunkToAppend);
                             // Try to start playback if paused and haven't started
                             if (audioElement.paused) {
                                 audioElement.play().catch(e => console.warn("Autoplay prevented:", e));
                             }
                        } catch (e) {
                            console.error('Error appending buffer:', e);
                            isAppending = false; // Reset flag on error
                        }
                    }
                }
                // --- End MSE Setup ---
                
                // Process the stream
                while (true) {
                    const { done, value } = await reader.read();
                    
                    if (done) {
                        console.log('Stream complete');
                        // Signal end of stream to MediaSource when backend is done
                        if (mediaSource.readyState === 'open' && sourceBuffer && !sourceBuffer.updating) {
                            mediaSource.endOfStream();
                        } else if (mediaSource.readyState === 'open' && sourceBuffer) {
                            // If buffer is updating, wait for it to finish before ending
                            sourceBuffer.addEventListener('updateend', () => {
                                if (mediaSource.readyState === 'open') { // Check again in case it closed
                                   mediaSource.endOfStream();
                                }
                            }, { once: true });
                        }
                        break;
                    }
                    
                    // Process the chunk
                    const chunk = decoder.decode(value, { stream: true });
                    const events = chunk.split('\n\n').filter(Boolean);
                    
                    for (const event of events) {
                        if (!event.startsWith('data: ')) continue;
                        
                        const jsonStr = event.slice(6);
                        try {
                            const eventData = JSON.parse(jsonStr);
                            
                            // Handle different event types
                            switch (eventData.event) {
                                case 'text':
                                    // Append text chunk to story
                                    storyText += eventData.data.chunk;
                                    if (storyTextDiv) {
                                        storyTextDiv.innerHTML = formatStoryText(storyText);
                                        // Scroll to bottom
                                        window.scrollTo(0, document.body.scrollHeight);
                                    }
                                    break;
                                    
                                case 'audio':
                                    // Process audio chunk
                                    const audioBase64 = eventData.data.chunk;
                                    const audioBytes = base64ToArrayBuffer(audioBase64);
                                    
                                    // Add to temporary queue
                                    audioQueue.push(audioBytes);
                                    
                                    // Attempt to append if sourceBuffer is ready and not busy
                                    appendNextChunk();
                                    break;
                                    
                                case 'complete':
                                    // Story generation complete
                                    document.getElementById('loadingContainer').style.display = 'none';
                                    document.getElementById('progressBar').style.width = '100%';
                                    
                                    console.log('Story generation complete:', eventData.data);
                                    break;
                                    
                                case 'error':
                                    console.error('Error from server:', eventData.data.message);
                                    throw new Error(eventData.data.message);
                                    
                                case 'metadata':
                                    console.log('Story metadata:', eventData.data);
                                    break;
                                    
                                default:
                                    console.log('Unknown event type:', eventData);
                            }
                        } catch (error) {
                            console.error('Error parsing event:', error, jsonStr);
                        }
                    }
                }
                
                // Update UI now that story is complete
                const loadingContainer = document.getElementById('loadingContainer');
                if (loadingContainer) {
                    loadingContainer.style.display = 'none';
                }
                
            } catch (error) {
                console.error('Error in streaming story generation:', error);
                
                // Clean up UI
                const storyResultContainer = document.getElementById('storyResult');
                if (storyResultContainer) {
                    storyResultContainer.style.display = 'none';
                }
                
                // Show error in UI
                const loadingMessage = document.getElementById('loadingMessage');
                if (loadingMessage) {
                    loadingMessage.innerHTML = `<i class="fas fa-exclamation-circle text-danger"></i> Error: ${error.message}`;
                }
                
                // Add a retry button
                const loadingContainer = document.getElementById('loadingContainer');
                if (loadingContainer) {
                    // Show the loading container since we're displaying an error
                    loadingContainer.style.display = 'block';
                    
                    // Add retry button if it doesn't exist
                    if (!loadingContainer.querySelector('button.retry-btn')) {
                        const retryBtn = document.createElement('button');
                        retryBtn.className = 'btn btn-primary mt-3 retry-btn';
                        retryBtn.innerHTML = '<i class="fas fa-sync-alt me-2"></i>Try Again';
                        retryBtn.onclick = () => {
                            document.getElementById('storyForm').style.display = 'block';
                            loadingContainer.style.display = 'none';
                            // Remove the retry button
                            while (loadingContainer.querySelector('button')) {
                                loadingContainer.querySelector('button').remove();
                            }
                        };
                        loadingContainer.appendChild(retryBtn);
                    }
                }
                
                // Show error notification
                showToast('Error generating story: ' + error.message, 'danger');
                throw error; // Re-throw to be caught by the outer try-catch
            }
        }
        
        // Helper function to format the story text with paragraphs
        function formatStoryText(text) {
            // Split by newlines and wrap in paragraphs
            return text.split('\n')
                .filter(line => line.trim() !== '')
                .map((line, index) => {
                    // First line is typically the title
                    if (index === 0 && !line.startsWith('Once upon a time')) {
                        return `<h2>${line}</h2>`;
                    }
                    return `<p>${line}</p>`;
                })
                .join('');
        }
        
        // Helper function to convert base64 to ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            
            return bytes.buffer;
        }
        
        // Function to simulate progress
        function simulateProgress() {
            const progressBar = document.getElementById('progressBar');
            const loadingMessage = document.getElementById('loadingMessage');
            let progress = 0;
            
            const messages = [
                "Gathering story elements...",
                "Creating characters...",
                "Building the plot...",
                "Adding magic touches...",
                "Generating story text...",
                "Creating audio narration..."
            ];
            
            // Clear any existing interval
            if (window.progressInterval) {
                clearInterval(window.progressInterval);
            }
            
            // Create new interval
            window.progressInterval = setInterval(() => {
                progress += 5;
                
                // If we're at the end, stop
                if (progress > 95) {
                    clearInterval(window.progressInterval);
                    return;
                }
                
                progressBar.style.width = progress + '%';
                
                // Update loading message at certain points
                if (progress === 20) loadingMessage.textContent = messages[1];
                else if (progress === 40) loadingMessage.textContent = messages[2];
                else if (progress === 60) loadingMessage.textContent = messages[3];
                else if (progress === 75) loadingMessage.textContent = messages[4];
                else if (progress === 90) loadingMessage.textContent = messages[5];
            }, 500);
            
            return window.progressInterval;
        }
        
        // Function to update the form with generated data
        function updateFormWithGeneratedData(data) {
            document.getElementById('universe').value = data.universe;
            document.getElementById('setting').value = data.setting;
            document.getElementById('theme').value = data.theme;
            document.getElementById('storyLength').value = data.story_length;
            
            // Reset character checkboxes
            document.querySelectorAll('.character-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            
            // Check the characters from the generated story
            data.characters.forEach(character => {
                document.querySelectorAll('.character-checkbox').forEach(checkbox => {
                    if (checkbox.value === character.character_name) {
                        checkbox.checked = true;
                    }
                });
            });
        }
        
        // Function to display the generated story
        function showStory(data) {
            // Hide loading indicator and show story result
            document.getElementById('loadingContainer').style.display = 'none';
            
            // If we have data, display it
            if (data) {
                // Update the form with generated data if randomize was used
                if (data.randomize) {
                    updateFormWithGeneratedData(data);
                }
                
                // Display the story
                displayStory(data);
            } else {
                // No data, just show the form again
                document.getElementById('storyForm').style.display = 'block';
            }
        }
        
        // Function to display the generated story
        function displayStory(data) {
            // Extract title from story text (assuming first line is the title)
            let storyLines = data.story_text.split('\n');
            let title = storyLines[0].replace(/^#+ /, ''); // Remove Markdown heading syntax
            
            // Set story title
            document.getElementById('storyTitle').textContent = title;
            
            // Format story text with paragraphs
            const formattedText = data.story_text.replace(/\n\n/g, '<br><br>');
            document.getElementById('storyText').innerHTML = formattedText;
            
            // Store the story ID for Home Assistant playback
            window.currentStoryId = data.id;
            
            // Set audio source if available
            if (data.audio_path) {
                const audioElement = document.getElementById('storyAudio');
                // Fix the path handling - ensure it has the /static/ prefix
                const audioPath = data.audio_path.startsWith('/static/') 
                    ? data.audio_path 
                    : '/static/' + data.audio_path;
                
                audioElement.src = audioPath;
                console.log('Setting audio source to:', audioPath);
                audioElement.load();
                
                // Set up Play Locally button
                const playLocallyBtn = document.getElementById('playLocallyBtn');
                playLocallyBtn.style.display = 'inline-block';
                playLocallyBtn.onclick = function() {
                    // Use the global player instead of playing directly
                    playAudioGlobal(audioPath, title);
                };
                
                // Show the Home Assistant button if there's audio
                const playOnHaBtn = document.getElementById('playOnHaBtn');
                playOnHaBtn.style.display = 'inline-block';
                playOnHaBtn.onclick = function() {
                    openHaPlayerSelector();
                };
            } else {
                // Hide buttons if no audio
                document.getElementById('playLocallyBtn').style.display = 'none';
                document.getElementById('playOnHaBtn').style.display = 'none';
            }
            
            // Show story result container
            document.getElementById('storyResult').style.display = 'block';
            
            // Scroll to the story result
            document.getElementById('storyResult').scrollIntoView({ behavior: 'smooth' });
        }
        
        // Load user preferences
        function loadUserPreferences() {
            try {
                fetch('/api/preferences/')
                    .then(response => {
                        if (!response.ok) {
                            throw new Error('Failed to load preferences');
                        }
                        return response.json();
                    })
                    .then(preferences => {
                        // Store preferences in localStorage for later access
                        localStorage.setItem('userPreferences', JSON.stringify(preferences));
                        console.log("Loaded user preferences:", preferences);
                        
                        // Apply preferences to form
                        
                        // Set child name
                        if (preferences.child_name) {
                            document.getElementById('childName').value = preferences.child_name;
                        }
                        
                        // Set universe preference 
                        if (preferences.favorite_universe) {
                            const universeSelect = document.getElementById('universe');
                            for (let i = 0; i < universeSelect.options.length; i++) {
                                if (universeSelect.options[i].value === preferences.favorite_universe) {
                                    universeSelect.selectedIndex = i;
                                    break;
                                }
                            }
                        }
                        
                        // Set favorite setting
                        if (preferences.favorite_setting) {
                            const settingSelect = document.getElementById('setting');
                            for (let i = 0; i < settingSelect.options.length; i++) {
                                if (settingSelect.options[i].value === preferences.favorite_setting) {
                                    settingSelect.selectedIndex = i;
                                    break;
                                }
                            }
                        }
                        
                        // Set favorite theme
                        if (preferences.favorite_theme) {
                            const themeSelect = document.getElementById('theme');
                            for (let i = 0; i < themeSelect.options.length; i++) {
                                if (themeSelect.options[i].value === preferences.favorite_theme) {
                                    themeSelect.selectedIndex = i;
                                    break;
                                }
                            }
                        }
                        
                        // Set story length preference
                        if (preferences.preferred_story_length) {
                            const lengthSelect = document.getElementById('storyLength');
                            for (let i = 0; i < lengthSelect.options.length; i++) {
                                if (lengthSelect.options[i].value === preferences.preferred_story_length) {
                                    lengthSelect.selectedIndex = i;
                                    break;
                                }
                            }
                        }
                        
                        // Set LLM provider
                        if (preferences.llm_provider) {
                            const providerSelect = document.getElementById('llmProvider');
                            for (let i = 0; i < providerSelect.options.length; i++) {
                                if (providerSelect.options[i].value === preferences.llm_provider) {
                                    providerSelect.selectedIndex = i;
                                    updateModelOptions(preferences.llm_provider);
                                    break;
                                }
                            }
                            
                            // If using local provider, check if we need to get models
                            if (preferences.llm_provider === 'local' && preferences.local_api_url) {
                                console.log("Local provider selected, checking for models");
                                fetchLocalModels(preferences.local_api_url, preferences.llm_model);
                            }
                        }
                        
                        // Set TTS provider and load voices
                        if (preferences.tts_provider) {
                            const ttsSelect = document.getElementById('ttsProvider');
                            for (let i = 0; i < ttsSelect.options.length; i++) {
                                if (ttsSelect.options[i].value === preferences.tts_provider) {
                                    ttsSelect.selectedIndex = i;
                                    loadVoices(preferences.tts_provider, preferences.voice_id);
                                    break;
                                }
                            }
                        } else {
                            // Load voices for the current selection if no preference
                            loadVoices(document.getElementById('ttsProvider').value);
                        }
                    })
                    .catch(error => {
                        console.error('Error loading preferences:', error);
                    });
            } catch (error) {
                console.error('Error in loadUserPreferences:', error);
            }
        }
        
        // Fetch local models from the API
        function fetchLocalModels(apiUrl, selectedModel) {
            console.log("Fetching local models with URL:", apiUrl);
            
            // Show loading in the dropdown
            const modelSelect = document.getElementById('modelSelect');
            modelSelect.innerHTML = '<option value="">Loading models...</option>';
            
            // Ensure we can see the model dropdown
            document.getElementById('modelSelectContainer').style.display = 'block';
            
            // Prepare the URL - add query parameter if API URL is set
            let fetchUrl = '/api/stories/models/local';
            if (apiUrl) {
                fetchUrl += `?api_url=${encodeURIComponent(apiUrl)}`;
            }
            
            console.log("Fetching models from:", fetchUrl);
            
            // Fetch the models
            fetch(fetchUrl)
                .then(response => response.json())
                .then(models => {
                    // Clear current options
                    modelSelect.innerHTML = '';
                    
                    // Check if we have models
                    if (models && Array.isArray(models) && models.length > 0) {
                        console.log("Loaded models:", models);
                        
                        // Add models to options
                        models.forEach(model => {
                            const option = document.createElement('option');
                            option.value = model;
                            option.textContent = model;
                            modelSelect.appendChild(option);
                        });
                        
                        // Check if we should select a specific model
                        if (selectedModel) {
                            console.log("Looking for selected model:", selectedModel);
                            
                            // Try to find and select the model
                            let found = false;
                            for (let i = 0; i < modelSelect.options.length; i++) {
                                if (modelSelect.options[i].value === selectedModel) {
                                    console.log("Found and selecting model:", selectedModel);
                                    modelSelect.selectedIndex = i;
                                    found = true;
                                    break;
                                }
                            }
                            
                            // If not found, select the first model
                            if (!found && modelSelect.options.length > 0) {
                                console.log("Selected model not found, selecting first model");
                                modelSelect.selectedIndex = 0;
                            }
                        } else if (modelSelect.options.length > 0) {
                            // Just select the first model if no preference
                            modelSelect.selectedIndex = 0;
                        }
                    } else {
                        // No models found, add a notice
                        modelSelect.innerHTML = `
                            <option value="">No models found</option>
                        `;
                        console.log("No models found or there was an error");
                    }
                })
                .catch(error => {
                    console.error('Error fetching local models:', error);
                    modelSelect.innerHTML = `
                        <option value="">Error loading models</option>
                    `;
                });
        }
        
        // Function to load voices for the selected TTS provider
        async function loadVoices(provider, selectedVoiceId = null) {
            const voiceContainer = document.getElementById('voiceSelectContainer');
            const voiceSelect = document.getElementById('voiceSelect');
            
            // Clear existing options
            voiceSelect.innerHTML = '';
            
            // If provider is 'none', hide the voice selector
            if (provider === 'none') {
                voiceContainer.style.display = 'none';
                return;
            } else {
                voiceContainer.style.display = 'block';
            }
            
            try {
                const response = await fetch(`/api/audio/voices?provider=${provider}`);
                
                if (!response.ok) {
                    throw new Error('Failed to load voices');
                }
                
                const voices = await response.json();
                
                // Sort voices by name
                voices.sort((a, b) => {
                    return a.name.localeCompare(b.name);
                });
                
                // Add options for each voice
                voices.forEach(voice => {
                    const option = document.createElement('option');
                    option.value = voice.voice_id;
                    
                    // Format the display name with gender and language if available
                    let displayName = voice.name;
                    if (voice.gender || voice.language) {
                        displayName += ' (';
                        if (voice.gender) {
                            displayName += voice.gender;
                        }
                        if (voice.gender && voice.language) {
                            displayName += ', ';
                        }
                        if (voice.language) {
                            displayName += voice.language;
                        }
                        displayName += ')';
                    }
                    
                    option.textContent = displayName;
                    voiceSelect.appendChild(option);
                    
                    // Select the voice if it matches the saved preference
                    if (selectedVoiceId && voice.voice_id === selectedVoiceId) {
                        option.selected = true;
                    }
                });
                
            } catch (error) {
                console.error('Error loading voices:', error);
                // Show error notification
                showToast('Error loading voices: ' + error.message, 'danger');
            }
        }
        
        // Function to initialize the model options
        function initializeModelOptions() {
            // Define model options for different providers
            window.modelOptions = {
                openai: [
                    { value: "gpt-4o", label: "GPT-4o" },
                    { value: "gpt-4o-mini", label: "GPT-4o Mini" },
                ],
                anthropic: [
                    { value: "claude-3-opus-20240229", label: "Claude 3 Opus" },
                    { value: "claude-3-sonnet-20240229", label: "Claude 3 Sonnet" },
                    { value: "claude-3-haiku-20240307", label: "Claude 3 Haiku" }
                ],
                azure: [
                    { value: "aoai-sds-gpt4o-mini-global", label: "GPT-4o Mini" }
                    // Users will need to fill this in based on their Azure setup
                ],
                local: [] // Will be populated from API
            };
            
            // Trigger initial setup of model options
            updateModelOptions(document.getElementById('llmProvider').value);
        }
        
        // Function to update model options based on the selected provider
        function updateModelOptions(provider) {
            const modelContainer = document.getElementById('modelSelectContainer');
            const modelSelect = document.getElementById('modelSelect');
            
            // Clear existing options
            modelSelect.innerHTML = "";
            
            if (provider in window.modelOptions) {
                // Show model selector and populate with options
                modelContainer.style.display = 'block';
                
                // For local provider, fetch models from API
                if (provider === 'local') {
                    // Fetch models every time local provider is selected
                    fetch('/api/preferences/')
                        .then(response => response.json())
                        .then(preferences => {
                            if (preferences.local_api_url) {
                                // If we have a saved API URL, use it to fetch models
                                const apiUrl = preferences.local_api_url;
                                console.log("Using saved local API URL:", apiUrl);
                                
                                // Make a request with the saved API URL
                                fetch(`/api/stories/models/local?api_url=${encodeURIComponent(apiUrl)}`)
                                    .then(response => response.json())
                                    .then(data => {
                                        // Process the models
                                        if (data && Array.isArray(data) && data.length > 0) {
                                            // Clear existing options
                                            window.modelOptions.local = [];
                                            modelSelect.innerHTML = "";
                                            
                                            // Add models to options
                                            data.forEach(model => {
                                                window.modelOptions.local.push({
                                                    value: model,
                                                    label: model
                                                });
                                                
                                                const option = document.createElement('option');
                                                option.value = model;
                                                option.textContent = model;
                                                modelSelect.appendChild(option);
                                            });
                                            
                                            // Check if there's a previously selected or preferred model
                                            if (preferences.llm_model && preferences.llm_provider === 'local') {
                                                const preferredModel = preferences.llm_model;
                                                console.log("Looking for preferred model:", preferredModel);
                                                
                                                // Try to find and select the preferred model
                                                let found = false;
                                                for (let i = 0; i < modelSelect.options.length; i++) {
                                                    if (modelSelect.options[i].value === preferredModel) {
                                                        console.log("Found and selecting preferred model");
                                                        modelSelect.selectedIndex = i;
                                                        found = true;
                                                        break;
                                                    }
                                                }
                                                
                                                // If not found, select the first model
                                                if (!found && modelSelect.options.length > 0) {
                                                    console.log("Preferred model not found, selecting first model");
                                                    modelSelect.selectedIndex = 0;
                                                }
                                            } else if (modelSelect.options.length > 0) {
                                                // Just select the first model if no preference
                                                modelSelect.selectedIndex = 0;
                                            }
                                            
                                            // Remove the notice if it exists
                                            const notice = document.getElementById('localApiNotice');
                                            if (notice) {
                                                notice.remove();
                                            }
                                        } else {
                                            showLocalApiConfigMessage(modelSelect);
                                        }
                                    })
                                    .catch(error => {
                                        console.error("Error fetching local models:", error);
                                        showLocalApiConfigMessage(modelSelect);
                                    });
                            } else {
                                showLocalApiConfigMessage(modelSelect);
                            }
                        })
                        .catch(error => {
                            console.error("Error fetching preferences:", error);
                            showLocalApiConfigMessage(modelSelect);
                        });
                } else {
                    // Populate with existing options for other providers
                    window.modelOptions[provider].forEach(option => {
                        const optElement = document.createElement('option');
                        optElement.value = option.value;
                        optElement.textContent = option.label;
                        modelSelect.appendChild(optElement);
                    });
                }
                
                // For Azure, show a field for deployment name
                if (provider === 'azure') {
                    // Placeholder for Azure-specific UI elements
                }
            } else {
                // Hide model selector
                modelContainer.style.display = 'none';
            }
        }
        
        // Helper function to show the Local API configuration message
        function showLocalApiConfigMessage(modelSelect) {
            // Show message about setting up in preferences
            modelSelect.innerHTML = "";
            const promptOption = document.createElement('option');
            promptOption.value = "";
            promptOption.textContent = "Configure Local API in Preferences first";
            promptOption.disabled = true;
            promptOption.selected = true;
            modelSelect.appendChild(promptOption);
            
            // Add an info message
            if (!document.getElementById('localApiNotice')) {
                const infoDiv = document.createElement('div');
                infoDiv.id = 'localApiNotice';
                infoDiv.className = 'alert alert-info mt-2';
                infoDiv.innerHTML = '<small><i class="fas fa-info-circle me-1"></i> Please set up your Local API URL in <a href="/preferences" target="_blank">Preferences</a> first</small>';
                modelSelect.parentNode.appendChild(infoDiv);
            }
        }
        
        // Home Assistant Integration
        let currentPlayingEntityId = null;
        let isPlaying = false;
        
        // Open Home Assistant player selector
        function openHaPlayerSelector() {
            if (!window.currentStoryId) {
                showToast('No story available to play', 'danger');
                return;
            }
            
            // Show the player selection modal
            const haPlayerModal = new bootstrap.Modal(document.getElementById('haPlayerModal'));
            haPlayerModal.show();
            
            // Load media players
            document.getElementById('ha-player-list').innerHTML = `
                <div class="text-center py-3">
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                    <p class="mt-2">Loading media players...</p>
                </div>
            `;
            
            fetch('/api/integrations/home-assistant/media-players')
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Failed to load media players');
                    }
                    return response.json();
                })
                .then(players => {
                    if (players.length === 0) {
                        document.getElementById('ha-player-list').innerHTML = `
                            <div class="alert alert-warning">
                                <i class="fas fa-exclamation-triangle me-2"></i> No media players found in your Home Assistant instance.
                            </div>
                        `;
                        return;
                    }
                    
                    let html = '<div class="list-group">';
                    players.forEach(player => {
                        // Show different styling based on player state
                        let stateClass = 'text-muted';
                        let stateIcon = 'fa-power-off';
                        
                        if (player.state === 'playing') {
                            stateClass = 'text-success';
                            stateIcon = 'fa-play';
                        } else if (player.state === 'paused') {
                            stateClass = 'text-warning';
                            stateIcon = 'fa-pause';
                        } else if (player.state === 'idle') {
                            stateClass = 'text-info';
                            stateIcon = 'fa-stop';
                        }
                        
                        html += `
                            <button class="list-group-item list-group-item-action player-select" data-entity-id="${player.entity_id}">
                                <div class="d-flex justify-content-between align-items-center">
                                    <div>
                                        <i class="fas fa-speaker me-2"></i>
                                        <strong>${player.name}</strong>
                                    </div>
                                    <div class="${stateClass}">
                                        <i class="fas ${stateIcon} me-1"></i>
                                        ${player.state}
                                    </div>
                                </div>
                            </button>
                        `;
                    });
                    html += '</div>';
                    
                    document.getElementById('ha-player-list').innerHTML = html;
                    
                    // Add event handler for player selection
                    document.querySelectorAll('.player-select').forEach(button => {
                        button.addEventListener('click', function() {
                            const entityId = this.getAttribute('data-entity-id');
                            playStoryOnHomeAssistant(window.currentStoryId, entityId);
                            bootstrap.Modal.getInstance(document.getElementById('haPlayerModal')).hide();
                        });
                    });
                })
                .catch(error => {
                    console.error('Error loading media players:', error);
                    document.getElementById('ha-player-list').innerHTML = `
                        <div class="alert alert-danger">
                            <i class="fas fa-exclamation-triangle me-2"></i> Error loading media players: ${error.message}
                        </div>
                    `;
                });
        }
        
        // Play story on Home Assistant
        function playStoryOnHomeAssistant(storyId, entityId) {
            const data = {
                story_id: storyId,
                entity_id: entityId
            };
            
            fetch('/api/integrations/home-assistant/play', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to play on Home Assistant');
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    showToast('Story is now playing on Home Assistant', 'success');
                    currentPlayingEntityId = entityId; // Store the entity ID
                    isPlaying = true; // Set playing state to true
                    updatePlayPauseButton(); // Update button state
                    document.getElementById('player-controls').classList.remove('d-none'); // Show player controls
                } else {
                    showToast('Failed to play story on Home Assistant', 'danger');
                }
            })
            .catch(error => {
                console.error('Error playing on Home Assistant:', error);
                showToast('Error: ' + error.message, 'danger');
            });
        }
        
        // Toggle play/pause state
        function togglePlayPause() {
            if (!currentPlayingEntityId) {
                showToast('No media is currently playing', 'warning');
                return;
            }
            
            if (isPlaying) {
                pauseMedia();
            } else {
                resumeMedia();
            }
        }
        
        // Pause media playback
        function pauseMedia() {
            if (!currentPlayingEntityId) return;
            
            const data = {
                entity_id: currentPlayingEntityId
            };
            
            fetch('/api/integrations/home-assistant/pause', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to pause media');
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    showToast('Media paused', 'info');
                    isPlaying = false;
                    updatePlayPauseButton();
                } else {
                    showToast('Failed to pause media', 'danger');
                }
            })
            .catch(error => {
                console.error('Error pausing media:', error);
                showToast('Error: ' + error.message, 'danger');
            });
        }
        
        // Resume media playback
        function resumeMedia() {
            if (!currentPlayingEntityId) return;
            
            const data = {
                entity_id: currentPlayingEntityId
            };
            
            fetch('/api/integrations/home-assistant/play_pause', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(data)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Failed to resume media');
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    showToast('Media resumed', 'info');
                    isPlaying = true;
                    updatePlayPauseButton();
                } else {
                    showToast('Failed to resume media', 'danger');
                }
            })
            .catch(error => {
                console.error('Error resuming media:', error);
                showToast('Error: ' + error.message, 'danger');
            });
        }
        
        // Update the play/pause button based on current state
        function updatePlayPauseButton() {
            const button = document.getElementById('pause-resume-ha-btn');
            if (isPlaying) {
                button.innerHTML = '<i class="fas fa-pause me-1"></i> Pause';
            } else {
                button.innerHTML = '<i class="fas fa-play me-1"></i> Resume';
            }
        }
        
        // Close player controls and stop playback
        document.getElementById('close-player-btn').addEventListener('click', function() {
            if (currentPlayingEntityId) {
                pauseMedia();
            }
            document.getElementById('player-controls').classList.add('d-none');
            currentPlayingEntityId = null;
        });
        
        // Add pause/resume button functionality
        document.getElementById('pause-resume-ha-btn').addEventListener('click', togglePlayPause);
        
        // Add new story button functionality
        document.getElementById('newStoryBtn').addEventListener('click', function() {
            // Hide story result and show form
            document.getElementById('storyResult').style.display = 'none';
            document.getElementById('storyForm').style.display = 'block';
        });
        
        // The global audio player function
        function playAudioGlobal(audioPath, title) {
            console.log('Playing audio from path:', audioPath);
            
            const audioElement = document.getElementById('storyAudio');
            audioElement.src = audioPath;
            audioElement.load();
            
            // Play the audio
            const playPromise = audioElement.play();
            
            // Handle play promise (required by some browsers)
            if (playPromise !== undefined) {
                playPromise.then(_ => {
                    // Playing started successfully
                    showToast(`Now playing: ${title}`, 'info');
                })
                .catch(error => {
                    // Auto-play prevented by browser
                    console.error('Error playing audio:', error);
                    showToast('Please click play again to start audio (browser prevented auto-play)', 'warning');
                });
            }
        }
        
        // Function to show toast notifications
        function showToast(message, type = 'info') {
            // Check if we have the Toast container, if not, create it
            let toastContainer = document.getElementById('toast-container');
            if (!toastContainer) {
                toastContainer = document.createElement('div');
                toastContainer.id = 'toast-container';
                toastContainer.className = 'toast-container position-fixed bottom-0 end-0 p-3';
                document.body.appendChild(toastContainer);
            }
            
            // Create a unique ID for this toast
            const toastId = 'toast-' + Date.now();
            
            // Create toast element
            const toastHtml = `
                <div id="${toastId}" class="toast align-items-center text-white bg-${type} border-0" role="alert" aria-live="assertive" aria-atomic="true">
                    <div class="d-flex">
                        <div class="toast-body">
                            ${message}
                        </div>
                        <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
                    </div>
                </div>
            `;
            
            // Add toast to container
            toastContainer.innerHTML += toastHtml;
            
            // Initialize and show the toast
            const toastElement = document.getElementById(toastId);
            const toast = new bootstrap.Toast(toastElement, {
                autohide: true,
                delay: 5000
            });
            toast.show();
        }
    });
</script>
{% endblock %}
